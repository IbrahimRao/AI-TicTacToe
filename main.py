# -*- coding: utf-8 -*-
"""main.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vBFlWLMQXTUvRiS7I74JpApe40VLuy0h
"""

import threading
import time
import random
from prettytable import PrettyTable
noOfNodes = [0,0,0,0]

"""#### Board Generation"""

board = [
	[ '_', '_', '_' ],
	[ '_', '_', '_' ],
	[ '_', '_', '_' ]
]

def generateRandomBoard(board):
    players = ['X', 'O']
    for k in range(random.randint(0, 9)):  # Randomly place 'X's and 'O's on the board
        empty_cells = [(i, j) for i in range(3) for j in range(3) if board[i][j] == '_']
        if empty_cells:
            i, j = random.choice(empty_cells)
            board[i][j] = players[k % 2]
    return board


def printBoard(board):
    for i in range(3):
        for j in range(3):
            print(board[i][j], end = " ")
        print()

printBoard(generateRandomBoard(board))

"""#### Min Max from GeekforGeeks (simple min max)"""

# Python3 program to find the next optimal move for a player
player, opponent = 'x', 'o'

# This function returns true if there are moves
# remaining on the board. It returns false if
# there are no moves left to play.
def isMovesLeft(board) :

	for i in range(3) :
		for j in range(3) :
			if (board[i][j] == '_') :
				return True
	return False

def isGameOver(b):
	for row in range(3) :
		if (b[row][0] == b[row][1] and b[row][1] == b[row][2] and b[row][0] != '_') :
			return True

	# Checking for Columns for X or O victory.
	for col in range(3) :

		if (b[0][col] == b[1][col] and b[1][col] == b[2][col] and b[0][col] != '_') :

			return True

	# Checking for Diagonals for X or O victory.
	if (b[0][0] == b[1][1] and b[1][1] == b[2][2] and b[0][0] != '_') :

		return True

	if (b[0][2] == b[1][1] and b[1][1] == b[2][0] and b[0][2] != '_') :

		return True

	return False

# This is the evaluation function as discussed
# in the previous article ( http://goo.gl/sJgv68 )
def evaluate(b, depth) :

	# Checking for Rows for X or O victory.
	for row in range(3) :
		if (b[row][0] == b[row][1] and b[row][1] == b[row][2]) :
			if (b[row][0] == player) :
				return 100 - depth
			elif (b[row][0] == opponent) :
				return -100 + depth

	# Checking for Columns for X or O victory.
	for col in range(3) :

		if (b[0][col] == b[1][col] and b[1][col] == b[2][col]) :

			if (b[0][col] == player) :
				return 100 - depth
			elif (b[0][col] == opponent) :
				return -100 + depth

	# Checking for Diagonals for X or O victory.
	if (b[0][0] == b[1][1] and b[1][1] == b[2][2]) :

		if (b[0][0] == player) :
			return 100 - depth
		elif (b[0][0] == opponent) :
			return -100 + depth

	if (b[0][2] == b[1][1] and b[1][1] == b[2][0]) :

		if (b[0][2] == player) :
			return 100 - depth
		elif (b[0][2] == opponent) :
			return -100 + depth

	# Else if none of them have won then return 0
	return 0

# This is the minimax function. It considers all
# the possible ways the game can go and returns
# the value of the board
def minimax(board, depth, isMax) :
	noOfNodes[0] += 1
	score = evaluate(board,depth)


	# evaluated score
	if (isGameOver(board)) :
		return score

	# If there are no more moves and no winner then
	# it is a tie
	if (isMovesLeft(board) == False) :
		return 0

	# If this maximizer's move
	if (isMax) :
		best = -1000

		# Traverse all cells
		for i in range(3) :
			for j in range(3) :

				# Check if cell is empty
				if (board[i][j]=='_') :

					# Make the move
					board[i][j] = player

					# Call minimax recursively and choose
					# the maximum value
					best = max( best, minimax(board,
											depth + 1,
											not isMax) )

					# Undo the move
					board[i][j] = '_'
		return best

	# If this minimizer's move
	else :
		best = 1000

		# Traverse all cells
		for i in range(3) :
			for j in range(3) :

				# Check if cell is empty
				if (board[i][j] == '_') :

					# Make the move
					board[i][j] = opponent

					# Call minimax recursively and choose
					# the minimum value
					best = min(best, minimax(board, depth + 1, not isMax))

					# Undo the move
					board[i][j] = '_'
		return best

# This will return the best possible move for the player
def findBestMove(board) :
	bestVal = -1000
	bestMove = (-1, -1)
	noOfNodes[0] = 0

	# Traverse all cells, evaluate minimax function for
	# all empty cells. And return the cell with optimal
	# value.
	for i in range(3) :
		for j in range(3) :

			# Check if cell is empty
			if (board[i][j] == '_') :

				# Make the move
				board[i][j] = player

				# compute evaluation function for this
				# move.
				moveVal = minimax(board, 0, False)

				# Undo the move
				board[i][j] = '_'

				# If the value of the current move is
				# more than the best value, then update
				# best/
				if (moveVal > bestVal) :
					bestMove = (i, j)
					bestVal = moveVal

	return bestMove


# This code is contributed by divyesh072019

# Driver code
board = [
	[ 'x', 'o', 'x' ],
	[ 'o', 'o', 'x' ],
	[ '_', '_', '_' ]
]

board2 = [
    [ 'x', 'x', 'o' ],
    [ '_', 'o', '_' ],
    [ '_','_','_']
]


bestMove = findBestMove(board2)

print("The Optimal Move is :")
print("ROW:", bestMove[0], " COL:", bestMove[1])

"""#### Min Max with Alpha Beta Pruning"""

# This is the evaluation function as discussed
# in the previous article ( http://goo.gl/sJgv68 )

# This is the minimax function. It considers all
# the possible ways the game can go and returns
# the value of the board
pruningCount = 0
def minimaxab(board, depth, isMax,alpha,beta) :
	noOfNodes[1] += 1
	score = evaluate(board,depth)
	global pruningCount

	# If Maximizer has won the game return his/her
	if (isGameOver(board)) :
		return score

	# If there are no more moves and no winner then
	# it is a tie
	if (isMovesLeft(board) == False) :
		return 0

	# If this maximizer's move
	if (isMax) :
		best = -1000

		# Traverse all cells
		for i in range(3) :
			for j in range(3) :

				# Check if cell is empty
				if (board[i][j]=='_') :

					# Make the move
					board[i][j] = player

					# Call minimax recursively and choose
					# the maximum value
					best = max( best, minimaxab(board, depth + 1, not isMax, alpha, beta) )

					# Undo the move
					board[i][j] = '_'
					alpha = max(alpha,best)

                    # Alpha Beta Pruning
					if beta <= alpha:
						pruningCount += 1
						return best



		return best

	# If this minimizer's move
	else :
		best = 1000

		# Traverse all cells
		for i in range(3) :
			for j in range(3) :

				# Check if cell is empty
				if (board[i][j] == '_') :

					# Make the move
					board[i][j] = opponent

					# Call minimax recursively and choose
					# the minimum value
					best = min(best, minimaxab(board, depth + 1, not isMax,alpha,beta))

					# Undo the move
					board[i][j] = '_'
					beta = min(beta,best)

                    # Alpha Beta Pruning
					if beta <= alpha:
						pruningCount += 1
						return best


		return best

# This will return the best possible move for the player
def findBestMoveAB(board) :
	bestVal = -1000
	bestMove = (-1, -1)
	alpha = -1000
	beta = 1000
	noOfNodes[1] = 0

	# Traverse all cells, evaluate minimax function for
	# all empty cells. And return the cell with optimal
	# value.
	for i in range(3) :
		for j in range(3) :

			# Check if cell is empty
			if (board[i][j] == '_') :

				# Make the move
				board[i][j] = player

				# compute evaluation function for this
				# move.
				moveVal = minimaxab(board, 0, False,alpha,beta)



				# Undo the move
				board[i][j] = '_'



				# If the value of the current move is
				# more than the best value, then update
				# best/
				if (moveVal > bestVal) :
					bestMove = (i, j)
					bestVal = moveVal
					alpha = max(alpha,bestVal)

	return bestMove


# This code is contributed by divyesh072019

# Driver code
board = [
	[ 'x', 'o', 'x' ],
	[ 'o', 'o', 'x' ],
	[ '_', '_', '_' ]
]

board2 = [
    [ 'x', 'x', 'o' ],
    [ '_', 'o', '_' ],
    [ '_','_','_']
]

bestMove = findBestMoveAB(board2)

print("The Optimal Move is :")
print("ROW:", bestMove[0], " COL:", bestMove[1])
print("pruning count: ", pruningCount)

"""#### MinMax Alpha Beta on 2 Threads"""

def minimaxabThread(board, depth, isMax,alpha,beta) :
	noOfNodes[2] += 1
	score = evaluate(board,depth)
	global pruningCount

	if (isGameOver(board)) :
		return score

	# If there are no more moves and no winner then
	# it is a tie
	if (isMovesLeft(board) == False) :
		return 0

	# If this maximizer's move
	if (isMax) :
		best = -1000

		# Traverse all cells
		for i in range(3) :
			for j in range(3) :

				# Check if cell is empty
				if (board[i][j]=='_') :

					# Make the move
					board[i][j] = player

					# Call minimax recursively and choose
					# the maximum value
					best = max( best, minimaxabThread(board, depth + 1, not isMax, alpha, beta) )

					# Undo the move
					board[i][j] = '_'
					alpha = max(alpha,best)

                    # Alpha Beta Pruning
					if beta <= alpha:
						pruningCount += 1
						return best



		return best

	# If this minimizer's move
	else :
		best = 1000

		# Traverse all cells
		for i in range(3) :
			for j in range(3) :

				# Check if cell is empty
				if (board[i][j] == '_') :

					# Make the move
					board[i][j] = opponent

					# Call minimax recursively and choose
					# the minimum value
					best = min(best, minimaxabThread(board, depth + 1, not isMax,alpha,beta))

					# Undo the move
					board[i][j] = '_'
					beta = min(beta,best)

                    # Alpha Beta Pruning
					if beta <= alpha:
						pruningCount += 1
						return best


		return best


# Lock For Shared Values
lock = threading.Lock()

# Global Variables shared among threads
bestVal = -1000
bestMove = (-1, -1)

# This will return the best possible move for the player

def findBestMoveABthread(board,moves) :
    localbestMove = (-1, -1)
    alpha = -1000
    beta = 1000
    localBestVal = -1000

    # Traverse all cells, evaluate minimax function for
	# all empty cells. And return the cell with optimal
	# value.

    for i,j in moves:
        # Check if cell is empty
        if (board[i][j] == '_') :

            # Make the move
            board[i][j] = player

            # compute evaluation function for this
            # move.
            moveVal = minimaxabThread(board, 0, False,alpha,beta)



            # Undo the move
            board[i][j] = '_'



            # If the value of the current move is
            # more than the best value, then update
            # best/
            if (moveVal > localBestVal) :
                localbestMove = (i, j)
                localBestVal = moveVal
                alpha = max(alpha,localBestVal)

    global bestVal
    global bestMove
    lock.acquire()
    if localBestVal > bestVal:
        bestVal = localBestVal
        bestMove = localbestMove
    lock.release()



def threadCreation(board):
    # Split all moves to check by 2 threads
    noOfNodes[2] = 0
    moves = []
    for i in range(3):
        for j in range(3):
            if board[i][j] == '_':
                moves.append((i,j))

    # Split moves into 2 lists
    moves1 = moves[:len(moves)//2]
    moves2 = moves[len(moves)//2:]

    # Create threads
    thread1 = threading.Thread(target=findBestMoveABthread, args=(board, moves1))
    thread2 = threading.Thread(target=findBestMoveABthread, args=(board, moves2))

    # Start threads
    thread1.start()
    thread2.start()

    # Wait for threads to finish
    thread1.join()
    thread2.join()

threadCreation(board2)
print("The value of the best Move is :", bestVal)
print("The Optimal Move is :")
print("ROW:", bestMove[0], " COL:", bestMove[1])

"""#### Heuristic Alpha Beta Pruning"""

def evaluateWithHeuristics(b,depth) :
    # Checking for Rows for X or O victory.
    for row in range(3) :
        if (b[row][0] == b[row][1] and b[row][1] == b[row][2]) :
            if (b[row][0] == player) :
                return 100 - depth
            elif (b[row][0] == opponent) :
                return -100 + depth

    # Checking for Columns for X or O victory.
    for col in range(3) :

        if (b[0][col] == b[1][col] and b[1][col] == b[2][col]) :

            if (b[0][col] == player) :
                return 100 - depth
            elif (b[0][col] == opponent) :
                return -100 + depth

    # Checking for Diagonals for X or O victory.
    if (b[0][0] == b[1][1] and b[1][1] == b[2][2]) :

        if (b[0][0] == player) :
            return 100 - depth
        elif (b[0][0] == opponent) :
            return -100 + depth

    if (b[0][2] == b[1][1] and b[1][1] == b[2][0]) :

        if (b[0][2] == player) :
            return 100 - depth
        elif (b[0][2] == opponent) :
            return -100 + depth


    # Check center occupancy
    score = 0
    if b[1][1] == player:
        score += 5
    elif b[1][1] == opponent:
        score += -5

    # Check corner occupancy
    corners = [(0, 0), (0, 2), (2, 0), (2, 2)]
    for x, y in corners:
        if b[x][y] == player:
            score += 2
        elif b[x][y] == opponent:
            score += -2

    # Else if none of them have won then return 0
    return 0




# Same functions as normal Alpha Beta Pruning but with evaluation function changed to evaluationWithHeuristics


# This is the minimax function. It considers all
# the possible ways the game can go and returns
# the value of the board
pruningCount = 0
def minimaxabHeuristic(board, depth, isMax,alpha,beta) :

	noOfNodes[3] += 1
	score = evaluateWithHeuristics(board,depth)
	global pruningCount

	if (isGameOver(board) or depth >= 2) :
		return score


	# If there are no more moves and no winner then
	# it is a tie
	if (isMovesLeft(board) == False) :
		return 0

	# If this maximizer's move
	if (isMax) :
		best = -1000

		# Traverse all cells
		for i in range(3) :
			for j in range(3) :

				# Check if cell is empty
				if (board[i][j]=='_') :

					# Make the move
					board[i][j] = player

					# Call minimax recursively and choose
					# the maximum value
					best = max( best, minimaxabHeuristic(board, depth + 1, not isMax, alpha, beta) )

					# Undo the move
					board[i][j] = '_'
					alpha = max(alpha,best)

                    # Alpha Beta Pruning
					if beta <= alpha:
						pruningCount += 1
						return best



		return best

	# If this minimizer's move
	else :
		best = 1000

		# Traverse all cells
		for i in range(3) :
			for j in range(3) :

				# Check if cell is empty
				if (board[i][j] == '_') :

					# Make the move
					board[i][j] = opponent

					# Call minimax recursively and choose
					# the minimum value
					best = min(best, minimaxabHeuristic(board, depth + 1, not isMax,alpha,beta))

					# Undo the move
					board[i][j] = '_'
					beta = min(beta,best)

                    # Alpha Beta Pruning
					if beta <= alpha:
						pruningCount += 1
						return best


		return best

# This will return the best possible move for the player
def findBestMoveABHeuristic(board) :

	bestVal = -1000
	bestMove = (-1, -1)
	alpha = -1000
	beta = 1000
	noOfNodes[3] = 0


	# Traverse all cells, evaluate minimax function for
	# all empty cells. And return the cell with optimal
	# value.
	for i in range(3) :
		for j in range(3) :

			# Check if cell is empty
			if (board[i][j] == '_') :

				# Make the move
				board[i][j] = player

				# compute evaluation function for this
				# move.
				moveVal = minimaxabHeuristic(board, 0, False,alpha,beta)



				# Undo the move
				board[i][j] = '_'



				# If the value of the current move is
				# more than the best value, then update
				# best/
				if (moveVal > bestVal) :
					bestMove = (i, j)
					bestVal = moveVal
					alpha = max(alpha,bestVal)


	return bestMove


# This code is contributed by divyesh072019

bestMove = findBestMoveABHeuristic(board2)

print("The Optimal Move is :")
print("ROW:", bestMove[0], " COL:", bestMove[1])
print("pruning count: ", pruningCount)

"""#### Execution Time Comparisons"""

# Execute each function 3 times and get Average Time in ms
def timeFunction(func, board):
    start = time.time()
    for i in range(10):
        func(board)
    end = time.time()
    return (end-start)*1000/10


print("Average Time for Normal Min Max: ", timeFunction(findBestMove, board2))
print("Average Nodes for Normal Min Max: ", noOfNodes[0])


print("Average Time for Normal Alpha Beta Pruning: ", timeFunction(findBestMoveAB, board2))
print("Average Nodes for Normal Alpha Beta Pruning: ", noOfNodes[1])


print("Average Time for Threaded Alpha Beta Pruning: ", timeFunction(threadCreation, board2))
print("Average Nodes for Threaded Alpha Beta Pruning: ", noOfNodes[2])


print("Average Time for Heuristic Alpha Beta Pruning: ", timeFunction(findBestMoveABHeuristic, board2))
print("Average Nodes for Heuristic Alpha Beta Pruning: ", noOfNodes[3])

"""#### Results"""

table = PrettyTable()

table.field_names = ["Algorithm", "Average Nodes", "Average Time(ms)"]
table.add_row(["Normal Min Max", noOfNodes[0], timeFunction(findBestMove, board2)])
table.add_row(["Normal Alpha Beta Pruning", noOfNodes[1], timeFunction(findBestMoveAB, board2)])
table.add_row(["Threaded Alpha Beta Pruning", noOfNodes[2], timeFunction(threadCreation, board2)])
table.add_row(["Heuristic Alpha Beta Pruning", noOfNodes[3], timeFunction(findBestMoveABHeuristic, board2)])
print(table)

"""#### Weak AI"""

def is_moves_left(board):
    return any('_' in row for row in board)


def print_board(board):
    for row in board:
        print("|".join(row))
    print()

def random_move(board, forbidden_tile):
    moves = [(i, j) for i in range(3) for j in range(3) if board[i][j] == '_' and (i, j) != forbidden_tile]
    return random.choice(moves) if moves else None

nodes_evaluated = 0


def play_game():
    board = [['_', '_', '_'] for _ in range(3)]
    forbidden_tile = (random.randint(0, 2), random.randint(0, 2))
    current_player = player if random.choice([True, False]) else opponent

    print("Starting board:")
    print_board(board)
    print(f"Forbidden tile for weak AI: {forbidden_tile}")

    while is_moves_left(board) and not evaluate(board,0):
        if current_player == opponent:  # Weak AI's move
            move = random_move(board, forbidden_tile)
            if not move:
                break
            print(f"Weak AI plays at {move}:")
            board[move[0]][move[1]] = opponent
        else:  # Strong AI's move (playing optimally using Minmax tree)
            move = findBestMove(board)
            if not move:
                break
            print(f"Player plays at {move}:")
            board[move[0]][move[1]] = player

        print_board(board)
        current_player = player if current_player == opponent else opponent

    score = evaluate(board,0)
    if score == 100:
        print("Player wins!")
    elif score == -100:
        print("Weak AI wins!")
    else:
        print("It's a draw!")

player = 'x'
opponent = 'o'
play_game()

board = [['x', 'o', '_'],
         ['x', '_', '_'],
         ['_', '_', 'o']
         ]

print(findBestMove(board))
print(findBestMoveAB(board))
print(findBestMoveABHeuristic(board))

